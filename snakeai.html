<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake AI Game</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #2c3e50;
        }
        canvas {
            border: 2px solid black;
            background-color: #2ecc71;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        const tile = 40;
        const rows = 20;
        const columns = 30;
        const border = 40;
        canvas.width = tile * columns + 2 * border;
        canvas.height = tile * rows + 2 * border;

        // Colors
        const snakeColor = "#FF0000";
        const appleColor = "#FFA500";
        const lightGreen = "#32CD32";
        const darkGreen = "#228B22";
        const evenDarkGreen = "#05472A";

        let snake = [{ x: 10, y: 10 }, { x: 10, y: 9 }, { x: 10, y: 8 }];
        let direction = "RIGHT";
        let apple = generateApple();
        let gameOver = false;

        // A* Pathfinding Algorithm
        function manhattanDistance(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        function aStar(snake, start, goal) {
            let openSet = [];
            openSet.push({ x: start.x, y: start.y });
            let cameFrom = new Map();
            let gScore = new Map();
            let fScore = new Map();
            gScore.set(`${start.x},${start.y}`, 0);
            fScore.set(`${start.x},${start.y}`, manhattanDistance(start, goal));

            while (openSet.length > 0) {
                openSet.sort((a, b) => fScore.get(`${a.x},${a.y}`) - fScore.get(`${b.x},${b.y}`));
                let current = openSet.shift();

                if (current.x === goal.x && current.y === goal.y) {
                    let path = [];
                    while (cameFrom.has(`${current.x},${current.y}`)) {
                        path.push(current);
                        current = cameFrom.get(`${current.x},${current.y}`);
                    }
                    return path.reverse();
                }

                let neighbors = [
                    { x: current.x - 1, y: current.y },
                    { x: current.x + 1, y: current.y },
                    { x: current.x, y: current.y - 1 },
                    { x: current.x, y: current.y + 1 }
                ];

                for (let neighbor of neighbors) {
                    if (neighbor.x >= 0 && neighbor.x < columns && neighbor.y >= 0 && neighbor.y < rows &&
                        !snake.some(s => s.x === neighbor.x && s.y === neighbor.y)) {
                        let tentativeGScore = (gScore.get(`${current.x},${current.y}`) || Infinity) + 1;

                        if (tentativeGScore < (gScore.get(`${neighbor.x},${neighbor.y}`) || Infinity)) {
                            cameFrom.set(`${neighbor.x},${neighbor.y}`, current);
                            gScore.set(`${neighbor.x},${neighbor.y}`, tentativeGScore);
                            fScore.set(`${neighbor.x},${neighbor.y}`, tentativeGScore + manhattanDistance(neighbor, goal));

                            if (!openSet.some(n => n.x === neighbor.x && n.y === neighbor.y)) {
                                openSet.push(neighbor);
                            }
                        }
                    }
                }
            }

            return null;
        }

        // Flood fill to check reachable area
        function floodFill(snake, head) {
            let visited = new Set();
            let queue = [head];
            visited.add(`${head.x},${head.y}`);
            let reachableArea = 0;

            while (queue.length > 0) {
                let current = queue.shift();
                reachableArea++;

                let neighbors = [
                    { x: current.x - 1, y: current.y },
                    { x: current.x + 1, y: current.y },
                    { x: current.x, y: current.y - 1 },
                    { x: current.x, y: current.y + 1 }
                ];

                for (let neighbor of neighbors) {
                    if (neighbor.x >= 0 && neighbor.x < columns && neighbor.y >= 0 && neighbor.y < rows &&
                        !visited.has(`${neighbor.x},${neighbor.y}`) &&
                        !snake.some(s => s.x === neighbor.x && s.y === neighbor.y)) {
                        visited.add(`${neighbor.x},${neighbor.y}`);
                        queue.push(neighbor);
                    }
                }
            }
            return reachableArea;
        }

        // Generate new apple location
        function generateApple() {
            let newApple;
            do {
                newApple = { x: Math.floor(Math.random() * columns), y: Math.floor(Math.random() * rows) };
            } while (snake.some(s => s.x === newApple.x && s.y === newApple.y));
            return newApple;
        }

        // Determine if a move keeps the tail reachable
        function isTailReachable(snake, newHead) {
            let newSnake = [newHead, ...snake.slice(0, -1)];
            return floodFill(newSnake, newSnake[newSnake.length - 1]) >= newSnake.length;
        }

        // Get next move using A* pathfinding
        function getNextMove(snake, apple) {
            let head = snake[0];
            let pathToApple = aStar(snake, head, apple);

            if (pathToApple) {
                let nextPosition = pathToApple[0];
                let newSnake = [nextPosition, ...snake.slice(0, -1)];
                if (floodFill(newSnake, newSnake[newSnake.length - 1]) >= newSnake.length) {
                    return nextPosition;
                }
            }

            let possibleMoves = [
                { x: head.x, y: head.y - 1, direction: "UP" },
                { x: head.x, y: head.y + 1, direction: "DOWN" },
                { x: head.x - 1, y: head.y, direction: "LEFT" },
                { x: head.x + 1, y: head.y, direction: "RIGHT" }
            ];

            let bestMove = null;
            let maxReachableArea = -1;

            for (let move of possibleMoves) {
                if (move.x >= 0 && move.x < columns && move.y >= 0 && move.y < rows &&
                    !snake.some(s => s.x === move.x && s.y === move.y)) {
                    let newSnake = [move, ...snake.slice(0, -1)];
                    let reachableArea = floodFill(newSnake, newSnake[newSnake.length - 1]);
                    if (reachableArea > maxReachableArea) {
                        maxReachableArea = reachableArea;
                        bestMove = move;
                    }
                }
            }

            return bestMove || { x: head.x, y: head.y - 1 }; // Default to UP if no better move is found
        }

        // Draw functions
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw border
            ctx.fillStyle = darkGreen;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw snake
            ctx.fillStyle = snakeColor;
            snake.forEach(segment => {
                ctx.fillRect(border + segment.x * tile, border + segment.y * tile, tile, tile);
            });

            // Draw apple
            ctx.fillStyle = appleColor;
            ctx.fillRect(border + apple.x * tile, border + apple.y * tile, tile, tile);

            if (gameOver) {
                ctx.fillStyle = "#FFFFFF";
                ctx.font = "40px Arial";
                ctx.fillText("Game Over!", canvas.width / 2 - 100, canvas.height / 2 - 20);
            }
        }

        // Event listener for controlling snake direction
        window.addEventListener("keydown", (e) => {
            if (gameOver) return;
            if (e.key === "ArrowUp" && direction !== "DOWN") {
                direction = "UP";
            } else if (e.key === "ArrowDown" && direction !== "UP") {
                direction = "DOWN";
            } else if (e.key === "ArrowLeft" && direction !== "RIGHT") {
                direction = "LEFT";
            } else if (e.key === "ArrowRight" && direction !== "LEFT") {
                direction = "RIGHT";
            }
        });

        // Game loop
        function gameLoop() {
            if (gameOver) return;

            let head = snake[0];
            let nextMove = getNextMove(snake, apple);

            if (nextMove) {
                snake.unshift(nextMove);
                if (nextMove.x === apple.x && nextMove.y === apple.y) {
                    apple = generateApple();
                } else {
                    snake.pop();
                }
            }

            // Check for collisions with walls or self
            if (snake.some((s, idx) => idx !== 0 && s.x === head.x && s.y === head.y) ||
                head.x < 0 || head.x >= columns || head.y < 0 || head.y >= rows) {
                gameOver = true;
                return;
            }

            drawGame();
            setTimeout(gameLoop, 100);
        }

        // Start game
        gameLoop();
    </script>
</body>
</html>
